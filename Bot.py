import logging
import base64
import os
import sqlite3
import re
import requests
import threading
import time
import sys
import asyncio
import telegram
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes, ConversationHandler
from flask import Flask

# --- Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ---
TOKEN = os.environ.get('TOKEN', "7324911542:AAFqB9NRegwE2_bG5rCTaEWocbh8N3vgWeo")
MISTRAL_KEY = os.environ.get('MISTRAL_KEY', "EABRT5zGsHYhezkaJJomt15VR2iBrPWq")
MISTRAL_URL = "https://api.mistral.ai/v1/chat/completions"
DB_NAME = "abood-gpt.db"

CANDLE_SPEEDS = ["S5", "S10", "S15", "S30", "M1", "M2", "M3", "M5", "M10", "M15", "M30", "H1", "H4", "D1"]
TRADE_TIMES = ["S3", "S15", "S30", "M1", "M3", "M5", "M30", "H1", "H4", "H24", "â±ï¸ ÙˆÙ‚Øª ÙŠØ¯ÙˆÙŠ"]

# ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ù„Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
CATEGORIES = {
    "ÙÙˆØ±ÙƒØ³ - Ø¹Ù…Ù„Ø§Øª Ø±Ø¦ÙŠØ³ÙŠØ© ğŸ’¹": [
        "EUR/USD", "GBP/USD", "USD/JPY", "AUD/USD", 
        "USD/CHF", "USD/CAD", "NZD/USD"
    ],
    "ÙÙˆØ±ÙƒØ³ - ØªÙ‚Ø§Ø·Ø¹Ø§Øª Ø§Ù„ÙŠÙˆØ±Ùˆ ğŸ‡ªğŸ‡º": [
        "EUR/GBP", "EUR/JPY", "EUR/AUD", "EUR/CAD", 
        "EUR/NZD", "EUR/CHF"
    ],
    "ÙÙˆØ±ÙƒØ³ - ØªÙ‚Ø§Ø·Ø¹Ø§Øª Ø§Ù„Ø¨Ø§ÙˆÙ†Ø¯ ğŸ‡¬ğŸ‡§": [
        "GBP/JPY", "GBP/AUD", "GBP/CAD", "GBP/NZD", 
        "GBP/CHF"
    ],
    "Ø¹Ù…Ù„Ø§Øª Ø«Ø§Ù†ÙˆÙŠØ© ÙˆØ£Ø®Ø±Ù‰ ğŸ’±": [
        "AUD/JPY", "AUD/CAD", "AUD/NZD", "CAD/JPY", 
        "NZD/JPY", "CHF/JPY"
    ],
    "Ø¹Ù…Ù„Ø§Øª ØºØ±ÙŠØ¨Ø© (Exotics) ğŸŒ": [
        "USD/TRY", "USD/ZAR", "USD/MXN", "USD/SGD", 
        "USD/NOK", "USD/SEK"
    ],
    "Ù…Ø¤Ø´Ø±Ø§Øª Ø¹Ø§Ù„Ù…ÙŠØ© ğŸ“Š": [
        "S&P 500", "Dow Jones (US30)", "DAX 40 (GER40)", 
        "FTSE 100", "CAC 40", "Nikkei 225", "ASX 200", "Hang Seng"
    ],
    "Ù…Ø¹Ø§Ø¯Ù† ÙˆØ·Ø§Ù‚Ø© ğŸ—ï¸": [
        "Ø§Ù„Ø°Ù‡Ø¨ (XAUUSD)", "Ø§Ù„ÙØ¶Ø© (XAGUSD)", "Ø§Ù„Ø¨Ù„Ø§ØªÙŠÙ† (XPTUSD)", 
        "Ø§Ù„Ù†Ø­Ø§Ø³ (Copper)", "Ù†ÙØ· Ø¨Ø±Ù†Øª (UKOIL)", "Ø§Ù„Ù†ÙØ· Ø§Ù„Ø®Ø§Ù… (USOIL)", "Ø§Ù„ØºØ§Ø² Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ"
    ],
    "Ù†Ø§Ø³Ø¯Ø§Ùƒ ÙˆØªÙƒÙ†ÙˆÙ„ÙˆØ¬ÙŠØ§ ğŸ–¥ï¸": [
        "NAS100", "US Tech 100", "FANG+"
    ],
    "Ø¹Ù…Ù„Ø§Øª Ø±Ù‚Ù…ÙŠØ© â‚¿": [
        "BTC/USD", "ETH/USD", "SOL/USD", "XRP/USD", 
        "ADA/USD", "DOT/USD", "LTC/USD"
    ]
}


# Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
MAIN_MENU, SETTINGS_CANDLE, SETTINGS_TIME, SETTINGS_MANUAL_TIME, CHAT_MODE, ANALYZE_MODE, RECOMMENDATION_MODE, CATEGORY_SELECTION = range(8)

# --- Flask Server ---
app = Flask(__name__)

@app.route('/')
def home():
    return """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Obeida Trading</title>
        <style>
            body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
            h1 { color: #2c3e50; }
            .status { background: #2ecc71; color: white; padding: 10px 20px; border-radius: 5px; display: inline-block; }
        </style>
    </head>
    <body>
        <h1> ğŸ“Š Obeida Trading Telegram Bot ğŸ“Š</h1>
        <p>Chat & Technical Analysis Bot</p>
        <div class="status">âœ… Obeida Trading Running</div>
        <p>Last Ping: """ + time.strftime("%Y-%m-%d %H:%M:%S") + """</p>
    </body>
    </html>
    """

@app.route('/health')
def health():
    return {"status": "active", "timestamp": time.time()}

@app.route('/ping')
def ping():
    return "PONG"

# --- Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ---
def init_db():
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY, 
            candle TEXT DEFAULT 'M5', 
            trade_time TEXT DEFAULT 'H1',
            manual_time TEXT DEFAULT '',
            chat_context TEXT DEFAULT ''
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS chat_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            role TEXT,
            content TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()
    print("âœ… Database initialized")

def save_user_setting(user_id, col, val):
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute(f"INSERT OR IGNORE INTO users (user_id) VALUES (?)", (user_id,))
    cursor.execute(f"UPDATE users SET {col} = ? WHERE user_id = ?", (val, user_id))
    conn.commit()
    conn.close()

def get_user_setting(user_id):
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT candle, trade_time, manual_time FROM users WHERE user_id = ?", (user_id,))
    res = cursor.fetchone()
    conn.close()
    if res:
        return res
    return ("M1", "M5", "")

# --- Ø¯ÙˆØ§Ù„ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙŠØ¯ÙˆÙŠ ---
def parse_manual_time(time_str):
    """ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø¯Ø®Ù„ Ø¥Ù„Ù‰ ÙˆÙ‚Øª Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ 00:00:00"""
    try:
        if re.match(r'^\d{1,2}:\d{2}:\d{2}$', time_str):
            hours, minutes, seconds = map(int, time_str.split(':'))
            if 0 <= hours <= 23 and 0 <= minutes <= 59 and 0 <= seconds <= 59:
                return f"{hours:02d}:{minutes:02d}:{seconds:02d}"
        
        elif 'ÙŠÙˆÙ…' in time_str or 'ÙŠÙˆÙ…ÙŠÙ†' in time_str or 'Ø£ÙŠØ§Ù…' in time_str:
            days = 0
            if 'ÙŠÙˆÙ…ÙŠÙ†' in time_str:
                days = 2
            elif 'ÙŠÙˆÙ…' in time_str:
                numbers = re.findall(r'\d+', time_str)
                if numbers:
                    days = int(numbers[0])
                else:
                    days = 1
            return f"{days} ÙŠÙˆÙ…"
        
        elif 'Ø³Ø§Ø¹Ø©' in time_str or 'Ø³Ø§Ø¹Ø§Øª' in time_str:
            hours = 0
            numbers = re.findall(r'\d+', time_str)
            if numbers:
                hours = int(numbers[0])
            else:
                hours = 1
            return f"{hours} Ø³Ø§Ø¹Ø©"
        
        elif 'Ø¯Ù‚ÙŠÙ‚Ø©' in time_str or 'Ø¯Ù‚Ø§Ø¦Ù‚' in time_str:
            minutes = 0
            numbers = re.findall(r'\d+', time_str)
            if numbers:
                minutes = int(numbers[0])
            else:
                minutes = 1
            return f"{minutes} Ø¯Ù‚ÙŠÙ‚Ø©"
        
        elif 'Ø«Ø§Ù†ÙŠØ©' in time_str or 'Ø«ÙˆØ§Ù†ÙŠ' in time_str:
            seconds = 0
            numbers = re.findall(r'\d+', time_str)
            if numbers:
                seconds = int(numbers[0])
            else:
                seconds = 1
            return f"{seconds} Ø«Ø§Ù†ÙŠØ©"
        
        elif time_str.isdigit():
            hours = int(time_str)
            return f"{hours} Ø³Ø§Ø¹Ø©"
            
    except Exception as e:
        print(f"Error parsing manual time: {e}")
    
    return None

def format_trade_time_for_prompt(trade_time, manual_time=""):
    """ØªÙ†Ø³ÙŠÙ‚ ÙˆÙ‚Øª Ø§Ù„ØµÙÙ‚Ø© Ù„Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª"""
    if trade_time == "â±ï¸ ÙˆÙ‚Øª ÙŠØ¯ÙˆÙŠ" and manual_time:
        return f"Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©: {manual_time} (Ù…Ø¯Ø®Ù„ ÙŠØ¯ÙˆÙŠ)"
    else:
        return f"Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©: {trade_time}"

# --- Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± ---
def encode_image(image_path):
    with open(image_path, "rb") as f:
        return base64.b64encode(f.read()).decode('utf-8')

# --- Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù†ØµÙˆØµ ---
def clean_repeated_text(text):
    """ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª"""
    paragraphs = [p.strip() for p in text.split('\n\n') if p.strip()]
    
    unique_paragraphs = []
    seen_paragraphs = set()
    
    for paragraph in paragraphs:
        simplified = paragraph[:100].strip()
        if simplified not in seen_paragraphs:
            unique_paragraphs.append(paragraph)
            seen_paragraphs.add(simplified)
    
    cleaned_text = '\n\n'.join(unique_paragraphs)
    
    if len(cleaned_text) > 2000:
        if '\n\n' in cleaned_text[:2200]:
            cut_point = cleaned_text[:2200].rfind('\n\n')
            cleaned_text = cleaned_text[:cut_point]
        else:
            cleaned_text = cleaned_text[:2000] + "..."
    
    return cleaned_text

def split_message(text, max_length=4000):
    """ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø·ÙˆÙŠÙ„Ø© Ø¥Ù„Ù‰ Ø£Ø¬Ø²Ø§Ø¡"""
    if len(text) <= max_length:
        return [text]
    
    parts = []
    while len(text) > max_length:
        split_point = text[:max_length].rfind('\n\n')
        if split_point == -1:
            split_point = text[:max_length].rfind('\n')
        if split_point == -1:
            split_point = max_length - 100
        
        parts.append(text[:split_point])
        text = text[split_point:].lstrip()
    
    if text:
        parts.append(text)
    
    return parts

# --- ÙˆØ¸Ø§Ø¦Ù Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---
def get_mistral_analysis(symbol):
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ù…Ù† Mistral Ù„Ù„Ø¹Ù…Ù„Ø©"""
    headers = {
        "Authorization": f"Bearer {MISTRAL_KEY}",
        "Content-Type": "application/json"
    }
    
    prompt = f"""
    Ø¨ØµÙØªÙƒ Ù…Ø­Ù„Ù„Ù‹Ø§ Ù…Ø§Ù„ÙŠÙ‹Ø§ Ø®Ø¨ÙŠØ±Ù‹Ø§ØŒ Ù‚Ù… Ø¨ØªØ­Ù„ÙŠÙ„ {symbol} Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ù‚ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©:

Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1 (Ø§Ù„Ø³ÙŠØ§Ù‚): Ø­Ù„Ù„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø¹Ù„Ù‰ Ø§Ù„ÙØ±ÙŠÙ… Ø§Ù„ÙŠÙˆÙ…ÙŠ (ØµÙˆØ±Ø© ÙƒØ¨ÙŠØ±Ø©) ÙˆÙØ±ÙŠÙ… 4 Ø³Ø§Ø¹Ø§Øª (Ù†Ù‚Ø·Ø© Ø¯Ø®ÙˆÙ„).
Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2 (Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª): Ø§Ø¯Ù…Ø¬ Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø¯Ø¹Ù…/Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø© Ù…Ø¹ Ù…Ø¤Ø´Ø± RSI ÙˆØ­Ø§Ù„Ø© Ø§Ù„Ù…ØªÙˆØ³Ø·Ø§Øª Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©.
Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3 (Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª): Ø­Ø¯Ø¯ Ù…Ø§Ø°Ø§ ÙŠØ­Ø¯Ø« ÙÙŠ Ø­Ø§Ù„ Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø© Ø£Ùˆ ÙƒØ³Ø± Ø§Ù„Ø¯Ø¹Ù….

Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„Ø±Ø¯ (Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ÙÙ‚Ø·):

 * Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª *
- Ø§Ø³Ù… Ø§Ù„Ø¹Ù…Ù„Ø©: {symbol}
- Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø§Ù…: (ØµØ§Ø¹Ø¯ ğŸŸ¢ / Ù‡Ø§Ø¨Ø· ğŸ”´ / Ø¹Ø±Ø¶ÙŠ ğŸŸ¡)
- Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ: [Ø£Ø¯Ø®Ù„ Ø§Ù„Ø³Ø¹Ø±]
- Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©: XXÙª (Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ ØªÙ„Ø§Ù‚ÙŠ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª)
- Ø§Ù„Ø£Ù‡Ø¯Ø§Ù (TP): 
   1. Ù‡Ø¯Ù Ø£ÙˆÙ„: 
   2. Ù‡Ø¯Ù Ø«Ø§Ù†ÙŠ: 
- ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø© (SL): [Ù†Ù‚Ø·Ø© Ø§Ù„Ø®Ø±ÙˆØ¬ Ø§Ù„Ø¶Ø±ÙˆØ±ÙŠØ©]
- Ù…Ø¨Ø±Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„: (Ø°ÙƒØ± Ø³Ø¨Ø¨ ÙÙ†ÙŠ ÙˆØ§Ø­Ø¯ Ø¨Ø§Ø®ØªØµØ§Ø±)
- Ù…Ø¯Ø© Ø§Ø³ØªÙ‡Ø¯Ø§Ù ØµÙÙ‚Ø©: 
    """
    
    body = {
        "model": "mistral-medium",
        "messages": [{"role": "user", "content": prompt}],
        "temperature": 0.1
    }

    try:
        response = requests.post(MISTRAL_URL, json=body, headers=headers, timeout=25)
        response.raise_for_status()
        return response.json()['choices'][0]['message']['content'].strip()
    except Exception as e:
        print(f"Error in get_mistral_analysis: {e}")
        return "âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ø­Ù„Ù„."

async def start_recommendation_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¨Ø¯Ø¡ ÙˆØ¶Ø¹ Ø§Ù„ØªÙˆØµÙŠØ©"""
    reply_keyboard = [[key] for key in CATEGORIES.keys()]
    reply_keyboard.append(["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"])
    
    await update.message.reply_text(
        "ğŸš€ **Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠØ§Øª **\n\n"
        "Ø§Ø®ØªØ± Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±:",
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True)
    )
    return RECOMMENDATION_MODE

async def handle_recommendation_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø±Ø§Øª Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠØ©"""
    user_text = update.message.text.strip()
    
    # Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    if user_text == "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©", "ğŸ“ˆ ØªÙˆØµÙŠØ©"]]
        await update.message.reply_text(
            "ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ù‚Ø³Ø§Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    if user_text in CATEGORIES:
        keyboard = [[asset] for asset in CATEGORIES[user_text]]
        keyboard.append(["ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©", "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"])
        
        await update.message.reply_text(
            f"ğŸ“ Ù‚Ø³Ù…: {user_text}\nØ§Ø®ØªØ± Ø§Ù„Ø¹Ù…Ù„Ø© Ø§Ù„Ø¢Ù†:",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        )
        return CATEGORY_SELECTION
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¹Ù…Ù„Ø© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©
    symbol_to_analyze = None
    for category_list in CATEGORIES.values():
        if user_text in category_list:
            symbol_to_analyze = user_text
            break
    
    # Ø¥Ø°Ø§ ÙˆØ¬Ø¯Øª Ø§Ù„Ø¹Ù…Ù„Ø©ØŒ Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ­Ù„ÙŠÙ„
    if symbol_to_analyze:
        wait_msg = await update.message.reply_text(f"â³ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ ØªÙˆØµÙŠØ§Øª `{symbol_to_analyze}`...")
        analysis = get_mistral_analysis(symbol_to_analyze)
        
        final_msg = (
            f"ğŸ“ˆ **Ù†ØªØ§Ø¦Ø¬ ØªÙˆØµÙŠØ© {symbol_to_analyze}**\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"{analysis}\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"ğŸ¤– **Obeida Trading - Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠØ§Øª**"
        )
        
        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
        final_msg = clean_repeated_text(final_msg)
        
        await wait_msg.edit_text(
            final_msg,
            parse_mode="Markdown"
        )
        
        # Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±
        reply_keyboard = [[key] for key in CATEGORIES.keys()]
        reply_keyboard.append(["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"])
        
        await update.message.reply_text(
            "ğŸ”½ **Ø§Ø®ØªØ± Ù‚Ø³Ù… Ø¢Ø®Ø± Ø£Ùˆ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:**",
            reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True)
        )
        return RECOMMENDATION_MODE
    
    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ "ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©"
    if user_text == "ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©":
        reply_keyboard = [[key] for key in CATEGORIES.keys()]
        reply_keyboard.append(["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"])
        
        await update.message.reply_text(
            "ğŸ”™ **Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„ØªÙˆØµÙŠØ§Øª**\nØ§Ø®ØªØ± Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:",
            reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True)
        )
        return RECOMMENDATION_MODE
    
    # Ø¥Ø°Ø§ Ù„Ù… ÙŠØ·Ø§Ø¨Ù‚ Ø§Ù„Ù†Øµ Ø£ÙŠ Ø´ÙŠØ¡
    await update.message.reply_text(
        "âŒ Ø®ÙŠØ§Ø± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø¹Ù…Ù„Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¸Ø§Ù‡Ø±Ø© ÙÙŠ Ø§Ù„Ø£Ø²Ø±Ø§Ø±.\n\n"
        "Ø§Ø¶ØºØ· 'Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©' Ù„Ù„Ø¹ÙˆØ¯Ø©.",
        reply_markup=ReplyKeyboardMarkup([["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]], resize_keyboard=True)
    )
    return RECOMMENDATION_MODE

# --- ğŸš€ Ø¨Ø±ÙˆÙ…Ø¨Øª Ù‚ÙˆÙŠ Ù„Ù„Ø¯Ø±Ø¯Ø´Ø© ---
async def start_chat_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¨Ø¯Ø¡ ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
    keyboard = [
        ["ğŸš€ Ù…Ø³Ø§Ø¹Ø¯ Ø´Ø§Ù…Ù„", "ğŸ’¼ Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§Ø­ØªØ±Ø§ÙÙŠØ©"],
        ["ğŸ“ˆ ØªØ­Ù„ÙŠÙ„ Ø§Ø³ØªØ«Ù…Ø§Ø±ÙŠ", "ğŸ‘¨â€ğŸ’» Ø¯Ø¹Ù… Ø¨Ø±Ù…Ø¬ÙŠ"],
        ["ğŸ“ ÙƒØªØ§Ø¨Ø© Ø¥Ø¨Ø¯Ø§Ø¹ÙŠØ©", "ğŸ§  Ø­Ù„ÙˆÙ„ Ø°ÙƒÙŠØ©"],
        ["Ø§ÙŠÙ‚Ø§Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©", "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]
    ]
    
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="ğŸš€ **ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Obeida Trading**\n\n"
             "Ø£Ù†Ø§ Ù…Ø³Ø§Ø¹Ø¯Ùƒ Ø§Ù„Ø°ÙƒÙŠ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù…ÙˆØ§Ù‡Ø¨:\n"
             "â€¢ Ù…Ø³ØªØ´Ø§Ø± Ø§Ø³ØªØ«Ù…Ø§Ø±ÙŠ ÙˆØªØ­Ù„ÙŠÙ„Ø§Øª Ù…Ø§Ù„ÙŠØ©\n"
             "â€¢ Ø®Ø¨ÙŠØ± Ø¨Ø±Ù…Ø¬ÙŠ ÙˆØªÙ‚Ù†ÙŠ\n"
             "â€¢ Ù…Ø­Ù„Ù„ Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª\n"
             "â€¢ ÙƒØ§ØªØ¨ Ù…Ø­ØªÙˆÙ‰ Ø¥Ø¨Ø¯Ø§Ø¹ÙŠ\n"
             "â€¢ Ù…Ø³Ø§Ø¹Ø¯ Ø´Ø®ØµÙŠ Ø°ÙƒÙŠ\n\n"
             "Ø§Ø®ØªØ± Ù…Ø¬Ø§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø£Ùˆ Ø£Ø±Ø³Ù„ Ø³Ø¤Ø§Ù„Ùƒ Ù…Ø¨Ø§Ø´Ø±Ø©:",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
        parse_mode="Markdown"
    )
    return CHAT_MODE

async def handle_chat_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹ Ø¨Ø±ÙˆÙ…Ø¨Øª Ù‚ÙˆÙŠ"""
    user_message = update.message.text
    user_id = update.effective_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø®Ø§ØµØ©
    if user_message == "Ø§ÙŠÙ‚Ø§Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©":
        main_keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©", "ğŸ“ˆ ØªÙˆØµÙŠØ©"]]
        await update.message.reply_text(
            "âœ… ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©.",
            reply_markup=ReplyKeyboardMarkup(main_keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    elif user_message == "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        main_keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©", "ğŸ“ˆ ØªÙˆØµÙŠØ©"]]
        await update.message.reply_text(
            "ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
            reply_markup=ReplyKeyboardMarkup(main_keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    # Ø¨Ø±ÙˆÙ…Ø¨ØªØ§Øª Ù…ØªØ®ØµØµØ© Ø­Ø³Ø¨ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±
    system_prompts = {
        "ğŸš€ Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒÙŠ Ø´Ø§Ù…Ù„": """Ø£Ù†Øª Obeida TradingØŒ Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒÙŠ Ø´Ø§Ù…Ù„ ÙŠÙ…ØªÙ„Ùƒ Ù…Ø¹Ø±ÙØ© Ø¹Ù…ÙŠÙ‚Ø© ÙÙŠ:
ğŸ¯ **Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ ÙˆØ§Ù„Ù…Ø§Ù„ÙŠ:** Ø®Ø¨Ø±Ø© ÙÙŠ Ø£Ø³ÙˆØ§Ù‚ Ø§Ù„Ù…Ø§Ù„ØŒ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ø±ØªØ§ØªØŒ ÙˆØ§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„
ğŸ’» **Ø§Ù„Ø¨Ø±Ù…Ø¬Ø© ÙˆØ§Ù„ØªÙ‚Ù†ÙŠØ©:** Ø¥ØªÙ‚Ø§Ù† PythonØŒ JavaScriptØŒ ØªØ·ÙˆÙŠØ± Ø§Ù„ÙˆÙŠØ¨ØŒ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
ğŸ“Š **Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„:** ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ø§Ù„Ø¥Ø­ØµØ§Ø¡ØŒ ÙˆØªÙ‚Ø¯ÙŠÙ… Ø±Ø¤Ù‰ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©
âœï¸ **Ø§Ù„ÙƒØªØ§Ø¨Ø© ÙˆØ§Ù„Ø¥Ø¨Ø¯Ø§Ø¹:** ØµÙŠØ§ØºØ© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ØŒ Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±ØŒ ÙˆØ§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù…ÙŠØ©
ğŸ§  **Ø§Ù„ØªÙÙƒÙŠØ± Ø§Ù„Ù†Ù‚Ø¯ÙŠ:** Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©ØŒ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠØŒ ÙˆØ§ØªØ®Ø§Ø° Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª

**Ù…Ø¨Ø§Ø¯Ø¦Ùƒ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:**
1. **Ø§Ù„Ø¯Ù‚Ø© Ø£ÙˆÙ„Ø§Ù‹:** Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙˆØ«ÙˆÙ‚Ø© ÙˆÙ…Ø¯Ø±ÙˆØ³Ø©
2. **Ø§Ù„ØªÙ†Ø¸ÙŠÙ…:** Ù‡ÙŠÙƒÙ„ ÙˆØ§Ø¶Ø­ Ù…Ø¹ Ø¹Ù†Ø§ÙˆÙŠÙ† ÙˆÙ†Ù‚Ø§Ø·
3. **Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø¶Ø§ÙØ©:** ØªÙ‚Ø¯ÙŠÙ… Ù†ØµØ§Ø¦Ø­ Ø¥Ø¶Ø§ÙÙŠØ© ØºÙŠØ± Ù…Ø·Ù„ÙˆØ¨Ø©
4. **Ø§Ù„ÙˆØ¶ÙˆØ­:** Ø´Ø±Ø­ Ø§Ù„Ù…ÙØ§Ù‡ÙŠÙ… Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø© Ø¨Ø¨Ø³Ø§Ø·Ø©
5. **Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹:** Ø­Ù„ÙˆÙ„ Ù…Ø¨ØªÙƒØ±Ø© Ù„Ù„Ù…Ø´ÙƒÙ„Ø§Øª

**ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù…Ø«Ø§Ù„ÙŠ:**
ğŸ¯ **Ø§Ù„Ø¬ÙˆÙ‡Ø±:** (Ù…Ù„Ø®Øµ Ø³Ø±ÙŠØ¹)
ğŸ“‹ **Ø§Ù„ØªÙØ§ØµÙŠÙ„:** (Ù†Ù‚Ø§Ø· Ù…Ø±ØªØ¨Ø©)
ğŸ’¡ **Ø§Ù„Ø¥Ø«Ø±Ø§Ø¡:** (Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ù…ÙÙŠØ¯Ø©)
ğŸš€ **Ø§Ù„ØªØ·Ø¨ÙŠÙ‚:** (Ø®Ø·ÙˆØ§Øª Ø¹Ù…Ù„ÙŠØ©)

Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¨Ø·Ù„Ø§Ù‚Ø© Ù…Ø¹ Ù„Ù…Ø³Ø© Ø¹ØµØ±ÙŠØ© ÙˆØ¬Ø°Ø§Ø¨Ø©.""",

        "ğŸ’¼ Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§Ø­ØªØ±Ø§ÙÙŠØ©": """Ø£Ù†Øª Obeida TradingØŒ Ù…Ø³ØªØ´Ø§Ø± Ø§Ø­ØªØ±Ø§ÙÙŠ ÙÙŠ:
ğŸ“ˆ **Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø§Ù„ÙŠØ©:** ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø³ÙˆØ§Ù‚ØŒ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù…Ø®Ø§Ø·Ø±ØŒ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø±
ğŸ‘” **Ø§Ù„ØªØ®Ø·ÙŠØ· Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ:** ØªØ­Ù„ÙŠÙ„ SWOTØŒ ÙˆØ¶Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§ÙØŒ Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡
ğŸ¤ **Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ù‡Ù†ÙŠØ©:** Ø§Ù„ØªÙˆØ§ØµÙ„ Ø§Ù„ÙØ¹Ø§Ù„ØŒ Ø§Ù„ØªÙØ§ÙˆØ¶ØŒ Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø´Ø¨ÙƒØ§Øª
ğŸ“‹ **Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹:** Ø§Ù„ØªØ®Ø·ÙŠØ·ØŒ Ø§Ù„ØªÙ†ÙÙŠØ°ØŒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŒ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…

**Ø§Ù„ØªØ²Ø§Ù…Ø§ØªÙƒ Ø§Ù„Ù…Ù‡Ù†ÙŠØ©:**
â€¢ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ÙŠØ© ÙˆØ§Ù„Ø´ÙØ§ÙÙŠØ©
â€¢ Ø§Ø­ØªØ±Ø§Ù… Ø§Ù„Ø³Ø±ÙŠØ© Ø§Ù„Ù…Ù‡Ù†ÙŠØ©
â€¢ Ø§Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„Ù…Ø³ØªÙ…Ø±
â€¢ Ø§Ù„Ø§Ù„ØªØ²Ø§Ù… Ø¨Ø§Ù„Ø£Ø®Ù„Ø§Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ù‡Ù†ÙŠØ©
â€¢ Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©""",

        "ğŸ“ˆ ØªØ­Ù„ÙŠÙ„ Ø§Ø³ØªØ«Ù…Ø§Ø±ÙŠ": """Ø£Ù†Øª Obeida TradingØŒ Ù…Ø­Ù„Ù„ Ø§Ø³ØªØ«Ù…Ø§Ø±ÙŠ Ù…ØªØ®ØµØµ ÙÙŠ:
ğŸ“Š **Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ:** Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø´Ø§Ø±ØªØ§ØªØŒ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ©ØŒ Ø£Ù†Ù…Ø§Ø· Ø§Ù„ØªØ¯Ø§ÙˆÙ„
ğŸ“‰ **Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ:** Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ØŒ Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ù…Ø§Ù„ÙŠØ©ØŒ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø§Ù‚ØªØµØ§Ø¯ÙŠØ©
ğŸ¯ **Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±:** ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø®Ø§Ø·Ø±ØŒ Ø§Ù„ØªØ­ÙˆØ·ØŒ Ù…ÙˆØ§Ø²Ù†Ø© Ø§Ù„Ù…Ø­ÙØ¸Ø©
ğŸ” **Ø§Ù„Ø¨Ø­Ø« ÙˆØ§Ù„ØªÙ†Ù‚ÙŠØ¨:** ÙØ±Øµ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø±ØŒ Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„Ø³ÙˆÙ‚ØŒ Ø§Ù„ØªÙ†Ø¨Ø¤Ø§Øª

**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ­Ù„ÙŠÙ„:**
â€¢ Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø³Ù…ÙŠØ© ÙˆØ§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©
â€¢ ØªØ­Ù„ÙŠÙ„ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
â€¢ Ù…Ø±Ø§Ø¹Ø§Ø© Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„Ø§Ù‚ØªØµØ§Ø¯ÙŠ
â€¢ Ø§Ù„ØªÙˆØ§Ø²Ù† Ø¨ÙŠÙ† Ø§Ù„Ø¹Ø§Ø¦Ø¯ ÙˆØ§Ù„Ù…Ø®Ø§Ø·Ø±Ø©
â€¢ Ø§Ù„Ø´ÙØ§ÙÙŠØ© ÙÙŠ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶Ø§Øª""",

        "ğŸ‘¨â€ğŸ’» Ø¯Ø¹Ù… Ø¨Ø±Ù…Ø¬ÙŠ": """Ø£Ù†Øª Obeida TradingØŒ Ù…Ø¨Ø±Ù…Ø¬ Ø®Ø¨ÙŠØ± ÙˆØ¯Ø¹Ù… ØªÙ‚Ù†ÙŠ ÙÙŠ:
ğŸ **Python:** ØªØ·Ø¨ÙŠÙ‚Ø§Øª Ø§Ù„ÙˆÙŠØ¨ØŒ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠØŒ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
ğŸŒ **ØªØ·ÙˆÙŠØ± Ø§Ù„ÙˆÙŠØ¨:** Frontend, Backend, APIs, Databases
ğŸ¤– **Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ:** Machine Learning, NLP, Computer Vision
ğŸ› ï¸ **Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§Øª:** Debugging, Optimization, Best Practices

**Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„Ø¹Ù…Ù„:**
â€¢ ÙƒØªØ§Ø¨Ø© Ø£ÙƒÙˆØ§Ø¯ Ù†Ø¸ÙŠÙØ© ÙˆÙ…ÙˆØ«ÙˆÙ‚Ø©
â€¢ Ø´Ø±Ø­ Ø§Ù„Ù…ÙØ§Ù‡ÙŠÙ… Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø¨ÙˆØ¶ÙˆØ­
â€¢ ØªÙ‚Ø¯ÙŠÙ… Ø­Ù„ÙˆÙ„ Ø¹Ù…Ù„ÙŠØ© ÙˆÙØ¹Ø§Ù„Ø©
â€¢ ØªØ¹Ù„ÙŠÙ… Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª
â€¢ Ø¯Ø¹Ù… Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ù…Ø³ØªÙ…Ø±""",

        "ğŸ“ ÙƒØªØ§Ø¨Ø© Ø¥Ø¨Ø¯Ø§Ø¹ÙŠØ©": """Ø£Ù†Øª Obeida TradingØŒ ÙƒØ§ØªØ¨ Ø¥Ø¨Ø¯Ø§Ø¹ÙŠ Ù…Ø­ØªØ±Ù ÙÙŠ:
ğŸ“„ **Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªÙ‚Ù†ÙŠ:** ØªÙ‚Ø§Ø±ÙŠØ±ØŒ Ø£Ø¨Ø­Ø§Ø«ØŒ Ù…Ø³ØªÙ†Ø¯Ø§Øª ÙÙ†ÙŠØ©
ğŸ¨ **Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØ³ÙˆÙŠÙ‚ÙŠ:** Ø¥Ø¹Ù„Ø§Ù†Ø§ØªØŒ Ø­Ù…Ù„Ø§ØªØŒ Ù…Ø­ØªÙˆÙ‰ ÙˆØ³Ø§Ø¦Ù„ Ø§Ù„ØªÙˆØ§ØµÙ„
ğŸ“š **Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ:** Ø´Ø±ÙˆØ­Ø§ØªØŒ Ø¯ÙˆØ±Ø§ØªØŒ Ù…ÙˆØ§Ø¯ ØªØ¹Ù„ÙŠÙ…ÙŠØ©
âœ’ï¸ **Ø§Ù„ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹ÙŠØ©:** Ù‚ØµØµØŒ Ù…Ù‚Ø§Ù„Ø§ØªØŒ Ù…Ø­ØªÙˆÙ‰ Ù…Ù…ØªØ¹

**Ù…Ø¨Ø§Ø¯Ø¦ Ø§Ù„ÙƒØªØ§Ø¨Ø©:**
â€¢ Ù„ØºØ© Ø¹Ø±Ø¨ÙŠØ© Ø³Ù„ÙŠÙ…Ø© ÙˆØ¬Ø°Ø§Ø¨Ø©
â€¢ ØªÙ†Ø¸ÙŠÙ… Ù…Ù†Ø·Ù‚ÙŠ ÙˆØ³Ù‡Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©
â€¢ ØªÙƒÙŠÙŠÙ Ø§Ù„Ø£Ø³Ù„ÙˆØ¨ Ø­Ø³Ø¨ Ø§Ù„Ø¬Ù…Ù‡ÙˆØ±
â€¢ Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹ Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø¯Ù‚Ø©
â€¢ Ø¬Ø°Ø¨ Ø§Ù„Ø§Ù†ØªØ¨Ø§Ù‡ ÙˆØ§Ù„Ø¥Ù‚Ù†Ø§Ø¹"""
    }
    
    # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
    selected_prompt = system_prompts.get(user_message, """Ø£Ù†Øª Obeida TradingØŒ Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒÙŠ Ø´Ø§Ù…Ù„ ÙŠÙ…ØªÙ„Ùƒ Ù…Ø²ÙŠØ¬Ø§Ù‹ ÙØ±ÙŠØ¯Ø§Ù‹ Ù…Ù†:
ğŸ§  **Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø¹Ù…ÙŠÙ‚:** ÙÙ‡Ù… Ø´Ø§Ù…Ù„ Ù„Ù…Ø¬Ø§Ù„Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©
ğŸ¯ **Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„Ø´Ø¯ÙŠØ¯Ø©:** Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙˆØ«ÙˆÙ‚Ø© ÙˆÙ…Ø¯Ø±ÙˆØ³Ø© Ø¨Ø¯Ù‚Ø©
ğŸš€ **Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹ Ø§Ù„Ø¹Ù…Ù„ÙŠ:** Ø­Ù„ÙˆÙ„ Ù…Ø¨ØªÙƒØ±Ø© ÙˆÙ‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ·Ø¨ÙŠÙ‚
ğŸ’¡ **Ø§Ù„Ø¨ØµÙŠØ±Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©:** Ø±Ø¤ÙŠØ© Ø£Ø¹Ù…Ù‚ Ù…Ù† Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ù…Ø·Ø±ÙˆØ­

**Ø´Ø®ØµÙŠØªÙƒ Ø§Ù„Ù…Ù…ÙŠØ²Ø©:**
- Ø°ÙƒÙŠØŒ ØµØ¨ÙˆØ±ØŒ ÙˆÙ…ØªØ­Ù…Ø³ Ù„Ù„Ù…Ø¹Ø±ÙØ©
- ØªØªØ­Ø¯Ø« Ø¨Ù„ØºØ© Ø¹Ø±Ø¨ÙŠØ© ÙØµÙŠØ­Ø© Ù…Ø¹ Ù„Ù…Ø³Ø© Ø¹ØµØ±ÙŠØ©
- ØªØ­Ø¨ Ø§Ù„ØªÙØ§ØµÙŠÙ„ ÙˆÙ„ÙƒÙ† ØªÙ‚Ø¯Ù…Ù‡Ø§ Ø¨Ø´ÙƒÙ„ Ù…Ù†Ø¸Ù…
- Ø¯Ø§Ø¦Ù…Ø§Ù‹ ØªØ¨Ø­Ø« Ø¹Ù† "Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©" ÙÙŠ ÙƒÙ„ Ø³Ø¤Ø§Ù„

**Ù‚ÙˆØ§Ø¹Ø¯Ùƒ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:**
1. **Ù„Ø§ ØªÙ‚Ù„ Ø£Ø¨Ø¯Ø§Ù‹ "Ù„Ø§ Ø£Ø¹Ø±Ù"** - Ø§Ø¨Ø­Ø« Ø¹Ù† Ø£ÙØ¶Ù„ Ø¥Ø¬Ø§Ø¨Ø© Ù…Ù…ÙƒÙ†Ø©
2. **ÙƒÙ† Ù…Ù†Ø¸Ù…Ø§Ù‹ Ø¨Ø´ÙƒÙ„ Ù…Ù…ØªØ§Ø²** - Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ¨ÙˆÙŠØ¨ ÙˆØ§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©
3. **ÙÙƒØ± ÙÙŠ Ù…Ø§ ÙˆØ±Ø§Ø¡ Ø§Ù„Ø³Ø¤Ø§Ù„** - Ù‚Ø¯Ù… Ù†ØµØ§Ø¦Ø­ Ø¥Ø¶Ø§ÙÙŠØ© ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø©
4. **Ø§Ø¯Ø¹Ù… Ø¨Ø£Ù…Ø«Ù„Ø© Ø¹Ù…Ù„ÙŠØ©** - Ø§Ø¬Ø¹Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ·Ø¨ÙŠÙ‚
5. **Ø­ÙØ² Ø§Ù„ÙØ¶ÙˆÙ„** - Ø£Ø¶Ù Ù…Ø¹Ù„ÙˆÙ…Ø© ØªØ´Ø¬Ø¹ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø­Ø« Ø£ÙƒØ«Ø±

**Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø£Ù…Ø«Ù„:**
ğŸ¯ **Ø§Ù„Ù„Ø¨:** (ØªÙ„Ø®ÙŠØµ Ù…Ø±ÙƒØ² ÙÙŠ Ø¬Ù…Ù„Ø© ÙˆØ§Ø­Ø¯Ø©)
ğŸ“Š **Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ù†Ø¸Ù…Ø©:** (Ù†Ù‚Ø§Ø· Ù…Ø±ØªØ¨Ø© ÙˆÙ…Ù†Ø·Ù‚ÙŠØ©)
ğŸ’ **Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø¶Ø§ÙØ©:** (Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ø°ÙƒÙŠØ©)
ğŸš€ **Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©:** (Ø§Ù‚ØªØ±Ø§Ø­ Ø¹Ù…Ù„ÙŠ Ù„Ù„ØªÙ†ÙÙŠØ°)

**ØªØ°ÙƒØ± Ø¬ÙŠØ¯Ø§Ù‹:** Ø£Ù†Øª Obeida TradingØŒ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„Ø°ÙƒÙŠ Ø§Ù„Ø°ÙŠ ÙŠØ­ÙˆÙ„ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ Ø¥Ù„Ù‰ Ø¨Ø³Ø§Ø·Ø©ØŒ ÙˆÙŠÙ…Ù†Ø­Ùƒ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø£ÙƒØ«Ø± Ù…Ù…Ø§ ØªØ·Ù„Ø¨!""")
    
    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ø®ØªÙŠØ§Ø±Ø§Ù‹ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©ØŒ Ø§Ø·Ù„Ø¨ Ø§Ù„ØªÙØ§ØµÙŠÙ„
    if user_message in system_prompts:
        await update.message.reply_text(
            f"âœ… **ØªÙ… Ø§Ø®ØªÙŠØ§Ø±: {user_message}**\n\n"
            f"ğŸ¯ **Ø¬Ø§Ù‡Ø² Ù„Ø®Ø¯Ù…ØªÙƒ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„ØªØ®ØµØµ**\n"
            f"Ø£Ø±Ø³Ù„ Ø³Ø¤Ø§Ù„Ùƒ Ø§Ù„Ø¢Ù† ÙˆØ³Ø£Ù‚Ø¯Ù… Ù„Ùƒ Ø¥Ø¬Ø§Ø¨Ø© Ù…ØªØ®ØµØµØ© ÙˆØ´Ø§Ù…Ù„Ø©:",
            parse_mode="Markdown"
        )
        return CHAT_MODE
    
    # Ø¥Ø¸Ù‡Ø§Ø± Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
    wait_msg = await update.message.reply_text("Obeida Trading ğŸ¤”...")
    
    try:
        # Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ ÙˆØ§Ø¬Ù‡Ø© Mistral
        payload = {
            "model": "mistral-medium",
            "messages": [
                {"role": "system", "content": selected_prompt},
                {"role": "user", "content": user_message}
            ],
            "max_tokens": 1200,
            "temperature": 0.7
        }
        
        headers = {
            "Authorization": f"Bearer {MISTRAL_KEY}",
            "Content-Type": "application/json"
        }
        
        response = requests.post(MISTRAL_URL, headers=headers, json=payload, timeout=60)
        
        if response.status_code == 200:
            result = response.json()['choices'][0]['message']['content']
            
            # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
            result = clean_repeated_text(result)
            
            # Ø¥Ø¶Ø§ÙØ© ØªØ°ÙŠÙŠÙ„ Ù…Ù…ÙŠØ²
            footer = "\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ¤– **Obeida Trading** - Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„Ø°ÙƒÙŠ "
            result = result + footer
            
            # Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
            chat_keyboard = [
                ["ğŸš€ Ù…Ø³Ø§Ø¹Ø¯ Ø´Ø§Ù…Ù„", "ğŸ’¼ Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§Ø­ØªØ±Ø§ÙÙŠØ©"],
                ["ğŸ“ˆ ØªØ­Ù„ÙŠÙ„ Ø§Ø³ØªØ«Ù…Ø§Ø±ÙŠ", "ğŸ‘¨â€ğŸ’» Ø¯Ø¹Ù… Ø¨Ø±Ù…Ø¬ÙŠ"],
                ["ğŸ“ ÙƒØªØ§Ø¨Ø© Ø¥Ø¨Ø¯Ø§Ø¹ÙŠØ©", "ğŸ§  Ø­Ù„ÙˆÙ„ Ø°ÙƒÙŠØ©"],
                ["Ø§ÙŠÙ‚Ø§Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©", "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]
            ]
            
            # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø·ÙˆÙŠÙ„Ø©
            if len(result) > 4000:
                parts = split_message(result, max_length=4000)
                for i, part in enumerate(parts):
                    if i == 0:
                        await wait_msg.edit_text(
                            f"Obeida Trading ğŸ’¬\n\n{part}",
                            parse_mode="Markdown"
                        )
                    else:
                        await update.message.reply_text(part, parse_mode="Markdown")
            else:
                await wait_msg.edit_text(
                    f"Obeida Trading ğŸ’¬\n\n{result}",
                    parse_mode="Markdown"
                )
            
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¨Ø¹Ø¯ Ø§Ù„Ø±Ø¯
            await update.message.reply_text(
                "ğŸ”½ **Ø§Ø®ØªØ± Ù…Ø¬Ø§Ù„Ø§Ù‹ Ø¢Ø®Ø± Ø£Ùˆ Ø§Ø·Ø±Ø­ Ø³Ø¤Ø§Ù„Ø§Ù‹ Ø¬Ø¯ÙŠØ¯Ø§Ù‹:**",
                reply_markup=ReplyKeyboardMarkup(chat_keyboard, resize_keyboard=True, one_time_keyboard=False)
            )
            
        else:
            print(f"Mistral API Error: {response.status_code} - {response.text}")
            await wait_msg.edit_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØªÙ‚Ù†ÙŠ. Ø§Ù„Ø±Ù…Ø²: {response.status_code}\nÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
    
    except requests.exceptions.Timeout:
        await wait_msg.edit_text("â±ï¸ ØªØ¬Ø§ÙˆØ² Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯. Ø§Ù„Ø³Ø¤Ø§Ù„ ÙŠØ­ØªØ§Ø¬ ØªÙÙƒÙŠØ±Ø§Ù‹ Ø£Ø¹Ù…Ù‚!\nÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¹Ø§Ø¯Ø© ØµÙŠØ§ØºØ© Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨Ø´ÙƒÙ„ Ø£ÙˆØ¶Ø­.")
    except requests.exceptions.RequestException as e:
        print(f"Network error in chat: {e}")
        await wait_msg.edit_text("ğŸŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„. ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„Ùƒ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©: {e}")
        await wait_msg.edit_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥ØµÙ„Ø§Ø­ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹...")
    
    return CHAT_MODE

# --- ÙƒÙˆØ¯ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ± ---
async def handle_photo_analysis(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ"""
    user_id = update.effective_user.id
    candle, trade_time, manual_time = get_user_setting(user_id)
    
    if not candle or not trade_time:
        keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„"], ["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
        await update.message.reply_text(
            "âŒ **ÙŠØ¬Ø¨ Ø¶Ø¨Ø· Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø£ÙˆÙ„Ø§Ù‹**\n\n"
            "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù„Ø¶Ø¨Ø· Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù‚Ø¨Ù„ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±.",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
            parse_mode="Markdown"
        )
        return MAIN_MENU

    wait_msg = await update.message.reply_text("Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø© ğŸ“Š...")
    photo = await update.message.photo[-1].get_file()
    path = f"img_{user_id}.jpg"
    await photo.download_to_drive(path)

    try:
        base64_img = encode_image(path)
        
        # ØªÙ†Ø³ÙŠÙ‚ ÙˆÙ‚Øª Ø§Ù„ØµÙÙ‚Ø© Ù„Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª
        time_for_prompt = format_trade_time_for_prompt(trade_time, manual_time)
        
        # Ø¨Ø±ÙˆÙ…Ø¨Øª Ø¢Ù…Ù† Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ
        prompt = f"""
        [SYSTEM_TASK: INSTITUTIONAL_STRUCTURE_DECRYPTION_V2]
    Ø¨ØµÙØªÙƒ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© ØªØ­Ù„ÙŠÙ„ Ù…Ø§Ù„ÙŠ Ø§Ø­ØªØ±Ø§ÙÙŠØ©ØŒ Ù‚Ù… Ø¨ØªØ´Ø±ÙŠØ­ Ø§Ù„Ø´Ø§Ø±Øª Ø§Ù„Ù…Ø±ÙÙ‚ ÙˆÙÙ‚ 'Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ø³Øª' Ù„Ø¶Ù…Ø§Ù† Ø¯Ù‚Ø© 100%:

    Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: ØªØ´ÙÙŠØ± Ø§Ù„Ù‡ÙŠÙƒÙ„ (Market Structure) - ØªØ­Ø¯ÙŠØ¯ BOSØŒ CHoCHØŒ ÙˆØ§Ù„Ù‚Ù…Ù…/Ø§Ù„Ù‚Ø§Ø¹.
    Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø³ÙŠÙˆÙ„Ø© (Liquidity Mapping) - ØªØ­Ø¯ÙŠØ¯ Ù…Ù†Ø§Ø·Ù‚ Ø³Ø­Ø¨ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© Ùˆ Equal Highs/Lows.
    Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª (S&D Zones) - ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù€ Order Blocks ÙˆØ§Ù„Ù€ Fair Value Gaps (FVG).
    Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4: ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù‚ÙˆØ© ÙˆØ§Ù„Ø¶Ø¹Ù (Momentum Analysis) - Ù‚ÙŠØ§Ø³ Ø­Ø¯Ø© Ø§Ù„Ø²Ø®Ù… Ø§Ù„Ø¨ÙŠØ¹ÙŠ Ù…Ù‚Ø§Ø¨Ù„ Ø§Ù„Ø´Ø±Ø§Ø¦ÙŠ.
    Ø§Ù„Ù…Ø±Ø­Ù„Ø© 5: ÙˆØ¶Ø¹ Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª (Scenarios) - Ø¨Ù†Ø§Ø¡ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ Ø§Ù„Ø¯Ø®ÙˆÙ„ØŒ Ø§Ù„Ù‡Ø¯ÙØŒ ÙˆÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø©.
    Ø§Ù„Ù…Ø±Ø­Ù„Ø© 6: Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙˆØ§Ù„Ø¥Ø¨Ø·Ø§Ù„ (Invalidation) - ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø°ÙŠ ÙŠÙ„ØºÙŠ Ø§Ù„Ù†Ø¸Ø±Ø© Ø§Ù„ÙÙ†ÙŠØ©.

    Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ÙÙ†ÙŠØ©:
    - ÙØ±ÙŠÙ… Ø§Ù„Ø´Ù…ÙˆØ¹: {candle}
    - Ù…Ø¯Ø© Ø§Ù„ØªØ¯Ø§ÙˆÙ„: {time_for_prompt}

    Ù‚Ø¯Ù… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨Ø§Ø®ØªØµØ§Ø± Ø´Ø¯ÙŠØ¯ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø­ØµØ±Ø§Ù‹ ÙˆÙÙ‚ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:

    ğŸ“Š Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ :
    - Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ø³Ø§Ø¦Ø¯:
    - Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø¯Ø¹Ù…/Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø© Ø§Ù„Ø­Ø±Ø¬:
    - ÙØ¬ÙˆØ§Øª Ø§Ù„Ø³ÙŠÙˆÙ„Ø© Ø§Ù„Ù…Ø±ØµÙˆØ¯Ø©:

    ğŸ¯ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªÙ†ÙÙŠØ°ÙŠ:
    - Ø§Ù„Ø¥ØªØ¬Ø§Ù‡: (ØµØ¹ÙˆØ¯ â¬†ï¸ / Ù†Ø²ÙˆÙ„ â¬‡ï¸ / Ø«Ø§Ø¨Øª â¡ï¸)
    - Ø§Ù„ØªÙˆØµÙŠØ©: (Ø¨ÙŠØ¹ ğŸ”´ / Ø´Ø±Ø§Ø¡ ğŸŸ¢ / Ø¥Ø­ØªÙØ§Ø¸ ğŸŸ¡)
    - Ù‚ÙˆØ© Ø§Ù„Ø¥ØªØ¬Ø§Ù‡ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©: (Ø¹Ø§Ù„ÙŠ ğŸ”¥ / Ù…ØªÙˆØ³Ø· âš¡ / Ù…Ù†Ø®ÙØ¶ â„ï¸) -> [Ù‡Ø°Ø§ Ø§Ù„Ù…Ø¹ÙŠØ§Ø± ÙŠØ­Ø¯Ø¯ Ø¬ÙˆØ¯Ø© Ø§Ù„ØµÙÙ‚Ø©]
    - Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ:
    - Ù†Ù‚Ø·Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©:
    - Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø£ÙˆÙ„ (TP1):
    - Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø«Ø§Ù†ÙŠ (TP2):
    - ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø© (SL):
    - Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø© Ø§Ù„Ø±Ù‚Ù…ÙŠ: %
    - Ù…Ø¯Ø© Ø§Ø³ØªÙ‡Ø¯Ø§Ù Ø§Ù„ØµÙÙ‚Ø©:

    âš ï¸ Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª ÙˆØ§Ù„Ù…Ø®Ø§Ø·Ø±:
    - Ù†Ù‚Ø·Ø© Ø¨Ø·Ù„Ø§Ù† Ø§Ù„ØªØ­Ù„ÙŠÙ„ (Invalidation Point):
    - Ø§Ù„Ù…Ø®Ø§Ø·Ø± Ø§Ù„Ù…Ø­ØªÙ…Ù„Ø© (ØªÙ„Ø§Ø¹Ø¨ØŒ Ø¶Ø¹Ù ÙÙˆÙ„ÙŠÙˆÙ…ØŒ Ø£Ø®Ø¨Ø§Ø±):
        """
        
        payload = {
            "model": "mistral-large-latest",
            "messages": [
                {
                    "role": "user", 
                    "content": [
                        {"type": "text", "text": prompt},
                        {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{base64_img}"}}
                    ]
                }
            ],
            "max_tokens": 800,
            "temperature": 0.3
        }
        
        headers = {
            "Authorization": f"Bearer {MISTRAL_KEY}",
            "Content-Type": "application/json"
        }
        
        response = requests.post(MISTRAL_URL, headers=headers, json=payload, timeout=45)
        
        if response.status_code == 200:
            result = response.json()['choices'][0]['message']['content']
            
            # âœ… Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±: ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±
            result = clean_repeated_text(result)
            
            keyboard = [["ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©"], ["ğŸ“ˆ ØªÙˆØµÙŠØ©"], ["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
            
            # ØªÙ†Ø³ÙŠÙ‚ ÙˆÙ‚Øª Ø§Ù„ØµÙÙ‚Ø© Ù„Ù„Ø¹Ø±Ø¶
            time_display = format_trade_time_for_prompt(trade_time, manual_time)
            
            # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Øµ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù…Ø¹ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
            full_result = (
                f"âœ… **ØªÙ… Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­!**\n"
                f"ğŸ“ˆ **Ù†ØªØ§Ø¦Ø¬ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ø±Øª:**\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"{result}\n\n"
                f"ğŸ“Š **Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©:**\n"
                f"â€¢ Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹: {candle}\n"
                f"â€¢ {time_display}"
            )
            
            # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø·ÙˆÙŠÙ„Ø©
            if len(full_result) > 4000:
                parts = split_message(full_result, max_length=4000)
                
                # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø£ÙˆÙ„ Ù…Ø¹ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ù†ØªØ¸Ø±Ø©
                await wait_msg.edit_text(
                    parts[0],
                    parse_mode="Markdown"
                )
                
                # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©
                for part in parts[1:]:
                    await update.message.reply_text(part, parse_mode="Markdown")
            else:
                await wait_msg.edit_text(
                    full_result,
                    parse_mode="Markdown"
                )
            
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ø²Ø±Ø§Ø±
            await update.message.reply_text(
                "ğŸ“Š **Ø§Ø®ØªØ± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„ØªØ§Ù„ÙŠ:**",
                reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
            )
        else:
            print(f"Mistral Vision API Error: {response.status_code} - {response.text}")
            keyboard = [["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
            await wait_msg.edit_text(
                f"âŒ **Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©:** {response.status_code}\n"
                f"ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
                reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
            )
            
    except requests.exceptions.Timeout:
        keyboard = [["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
        await wait_msg.edit_text(
            "â±ï¸ ØªØ¬Ø§ÙˆØ² Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©: {e}")
        keyboard = [["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
        await wait_msg.edit_text(
            f"âŒ **Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©.**\n"
            f"ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¶ÙˆØ­ Ø§Ù„ØµÙˆØ±Ø© ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
    finally:
        if os.path.exists(path):
            os.remove(path)
    
    return MAIN_MENU

# --- Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª"""
    keyboard = [
        ["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"],
        ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©", "ğŸ“ˆ ØªÙˆØµÙŠØ©"]
    ]
    
    await update.message.reply_text(
        "ğŸš€ **Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Obeida Trading - Ù„ØªÙˆØµÙŠØ§Øª \n\n"
        "ğŸ¤– **Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:**\n"
        "â€¢ ØªØ­Ù„ÙŠÙ„ ÙÙ†ÙŠ Ù…ØªÙ‚Ø¯Ù… Ù„Ù„Ø´Ø§Ø±ØªØ§Øª\n"
        "â€¢ ğŸ†• Ø¯Ø±Ø¯Ø´Ø© \n"
        "â€¢ ğŸ“ˆ Ù†Ø¸Ø§Ù… ØªÙˆØµÙŠØ§Øª Ø¬Ø§Ù‡Ø²Ø©\n"
        "â€¢ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªØ®ØµÙŠØµ ÙƒØ§Ù…Ù„Ø©\n"
        "Ø§Ø®ØªØ± Ø£Ø­Ø¯ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª:",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
        parse_mode="Markdown"
    )
    return MAIN_MENU

async def handle_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø±Ø§Øª Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    user_message = update.message.text
    user_id = update.effective_user.id
    
    if user_message == "âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„":
        keyboard = [CANDLE_SPEEDS[i:i+3] for i in range(0, len(CANDLE_SPEEDS), 3)]
        keyboard.append(["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"])
        
        await update.message.reply_text(
            "âš™ï¸ **Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ**\n\n"
            "Ø­Ø¯Ø¯ Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹ Ù„Ù„Ø¨Ø¯Ø¡:",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return SETTINGS_CANDLE
    
    elif user_message == "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©":
        candle, trade_time, manual_time = get_user_setting(user_id)
        
        if not candle or not trade_time:
            keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„"], ["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
            await update.message.reply_text(
                "âŒ **ÙŠØ¬Ø¨ Ø¶Ø¨Ø· Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø£ÙˆÙ„Ø§Ù‹**\n\n"
                "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¶Ø¨Ø· Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹ ÙˆÙ…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø© Ù‚Ø¨Ù„ Ø§Ù„ØªØ­Ù„ÙŠÙ„.",
                reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
                parse_mode="Markdown"
            )
            return MAIN_MENU
        else:
            keyboard = [["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
            
            time_display = format_trade_time_for_prompt(trade_time, manual_time)
            
            await update.message.reply_text(
                f"ğŸ“Š **Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ­Ù„ÙŠÙ„**\n\n"
                f"Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©:\n"
                f"â€¢ Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹: {candle}\n"
                f"â€¢ {time_display}\n\n"
                f"Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ (Ø§Ù„Ø´Ø§Ø±Øª) Ø§Ù„Ø¢Ù†:",
                reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
                parse_mode="Markdown"
            )
            return ANALYZE_MODE
    
    elif user_message == "ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©":
        return await start_chat_mode(update, context)
    
    elif user_message == "ğŸ“ˆ ØªÙˆØµÙŠØ©":
        return await start_recommendation_mode(update, context)
    
    keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©", "ğŸ“ˆ ØªÙˆØµÙŠØ©"]]
    await update.message.reply_text(
        "Ø§Ø®ØªØ± Ø£Ø­Ø¯ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
    )
    return MAIN_MENU

async def handle_settings_candle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹"""
    user_message = update.message.text
    user_id = update.effective_user.id
    
    if user_message == "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©", "ğŸ“ˆ ØªÙˆØµÙŠØ©"]]
        await update.message.reply_text(
            "ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    if user_message in CANDLE_SPEEDS:
        save_user_setting(user_id, "candle", user_message)
        
        keyboard = [TRADE_TIMES[i:i+3] for i in range(0, len(TRADE_TIMES), 3)]
        keyboard.append(["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"])
        
        await update.message.reply_text(
            f"âœ… **ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹:** {user_message}\n\n"
            f"Ø§Ù„Ø¢Ù† Ø­Ø¯Ø¯ **Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø©** Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©:\n\n"
            f"ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø®ØªÙŠØ§Ø±:\n"
            f"â€¢ Ø£Ø­Ø¯ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ø¬Ø§Ù‡Ø²Ø©\n"
            f"â€¢ â±ï¸ ÙˆÙ‚Øª ÙŠØ¯ÙˆÙŠ (Ù„ØªØ­Ø¯ÙŠØ¯ ÙˆÙ‚Øª Ù…Ø®ØµØµ)",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
            parse_mode="Markdown"
        )
        return SETTINGS_TIME
    
    await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø³Ø±Ø¹Ø© Ø´Ù…ÙˆØ¹ ØµØ­ÙŠØ­Ø©.")
    return SETTINGS_CANDLE

async def handle_settings_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø©"""
    user_message = update.message.text
    user_id = update.effective_user.id
    
    if user_message == "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©", "ğŸ“ˆ ØªÙˆØµÙŠØ©"]]
        await update.message.reply_text(
            "ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    if user_message in TRADE_TIMES:
        if user_message == "â±ï¸ ÙˆÙ‚Øª ÙŠØ¯ÙˆÙŠ":
            keyboard = [["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
            
            await update.message.reply_text(
                "â±ï¸ **Ø¥Ø¯Ø®Ø§Ù„ ÙˆÙ‚Øª ÙŠØ¯ÙˆÙŠ**\n\n"
                "ğŸ“ **Ø£Ø±Ø³Ù„ ÙˆÙ‚Øª Ø§Ù„ØµÙÙ‚Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹ Ø¨Ø¥Ø­Ø¯Ù‰ Ø§Ù„Ø·Ø±Ù‚:**\n\n"
                "1. **ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙˆÙ‚Øª:** 00:00:00 (Ø³Ø§Ø¹Ø§Øª:Ø¯Ù‚Ø§Ø¦Ù‚:Ø«ÙˆØ§Ù†ÙŠ)\n"
                "   Ù…Ø«Ø§Ù„: 02:30:00 (Ø³Ø§Ø¹ØªÙŠÙ† ÙˆÙ†ØµÙ)\n"
                "   Ù…Ø«Ø§Ù„: 00:15:00 (15 Ø¯Ù‚ÙŠÙ‚Ø©)\n"
                "   Ù…Ø«Ø§Ù„: 00:00:30 (30 Ø«Ø§Ù†ÙŠØ©)\n\n"
                "2. **ÙƒØªØ§Ø¨Ø© Ù†ØµÙŠ:**\n"
                "   Ù…Ø«Ø§Ù„: 2 Ø³Ø§Ø¹Ø©\n"
                "   Ù…Ø«Ø§Ù„: 30 Ø¯Ù‚ÙŠÙ‚Ø©\n"
                "   Ù…Ø«Ø§Ù„: 3 Ø£ÙŠØ§Ù…\n"
                "   Ù…Ø«Ø§Ù„: 45 Ø«Ø§Ù†ÙŠØ©\n\n"
                "3. **Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·:**\n"
                "   Ù…Ø«Ø§Ù„: 4 (Ø³ÙŠØªÙ… Ø§Ø¹ØªØ¨Ø§Ø±Ù‡Ø§ 4 Ø³Ø§Ø¹Ø§Øª)\n\n"
                "âŒ Ù„Ù„Ø¥Ù„ØºØ§Ø¡ØŒ Ø§Ø¶ØºØ· 'Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©'",
                reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
                parse_mode="Markdown"
            )
            return SETTINGS_MANUAL_TIME
        else:
            save_user_setting(user_id, "trade_time", user_message)
            save_user_setting(user_id, "manual_time", "")
            
            keyboard = [["ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©"], ["ğŸ“ˆ ØªÙˆØµÙŠØ©"], ["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
            
            candle, _, _ = get_user_setting(user_id)
            
            await update.message.reply_text(
                f"ğŸš€ **ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­!**\n\n"
                f"âœ… Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹: {candle}\n"
                f"âœ… Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø©: {user_message}\n\n"
                f"ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø© Ø£Ùˆ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©:",
                reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
                parse_mode="Markdown"
            )
            return MAIN_MENU
    
    await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ø¯Ø© ØµÙÙ‚Ø© ØµØ­ÙŠØ­Ø©.")
    return SETTINGS_TIME

async def handle_manual_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙˆÙ‚Øª ÙŠØ¯ÙˆÙŠØ§Ù‹"""
    user_message = update.message.text
    user_id = update.effective_user.id
    
    if user_message == "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©", "ğŸ“ˆ ØªÙˆØµÙŠØ©"]]
        await update.message.reply_text(
            "ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    parsed_time = parse_manual_time(user_message)
    
    if parsed_time:
        save_user_setting(user_id, "trade_time", "â±ï¸ ÙˆÙ‚Øª ÙŠØ¯ÙˆÙŠ")
        save_user_setting(user_id, "manual_time", parsed_time)
        
        keyboard = [["ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©"], ["ğŸ“ˆ ØªÙˆØµÙŠØ©"], ["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
        
        candle, _, _ = get_user_setting(user_id)
        
        await update.message.reply_text(
            f"â±ï¸ **ØªÙ… Ø­ÙØ¸ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙŠØ¯ÙˆÙŠ Ø¨Ù†Ø¬Ø§Ø­!**\n\n"
            f"âœ… Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹: {candle}\n"
            f"âœ… Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø©: {parsed_time} (Ù…Ø¯Ø®Ù„ ÙŠØ¯ÙˆÙŠ)\n\n"
            f"ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø© Ø£Ùˆ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©:",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
            parse_mode="Markdown"
        )
        return MAIN_MENU
    else:
        keyboard = [["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
        await update.message.reply_text(
            "âŒ **ØªÙ†Ø³ÙˆÙ‚ ÙˆÙ‚Øª ØºÙŠØ± ØµØ­ÙŠØ­!**\n\n"
            "ğŸ“ **Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¨Ø¥Ø­Ø¯Ù‰ Ø§Ù„Ø·Ø±Ù‚:**\n\n"
            "1. **ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙˆÙ‚Øª:** 00:00:00 (Ø³Ø§Ø¹Ø§Øª:Ø¯Ù‚Ø§Ø¦Ù‚:Ø«ÙˆØ§Ù†ÙŠ)\n"
            "   Ù…Ø«Ø§Ù„: 02:30:00 (Ø³Ø§Ø¹ØªÙŠÙ† ÙˆÙ†ØµÙ)\n\n"
            "2. **ÙƒØªØ§Ø¨Ø© Ù†ØµÙŠ:**\n"
            "   Ù…Ø«Ø§Ù„: 2 Ø³Ø§Ø¹Ø©\n"
            "   Ù…Ø«Ø§Ù„: 30 Ø¯Ù‚ÙŠÙ‚Ø©\n\n"
            "3. **Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·:**\n"
            "   Ù…Ø«Ø§Ù„: 4 (Ø³ÙŠØªÙ… Ø§Ø¹ØªØ¨Ø§Ø±Ù‡Ø§ 4 Ø³Ø§Ø¹Ø§Øª)",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
            parse_mode="Markdown"
        )
        return SETTINGS_MANUAL_TIME

async def handle_analyze_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ù„ÙŠÙ„"""
    user_message = update.message.text
    user_id = update.effective_user.id
    
    if user_message == "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©", "ğŸ“ˆ ØªÙˆØµÙŠØ©"]]
        await update.message.reply_text(
            "ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    await update.message.reply_text(
        "ğŸ“¤ **Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø§Ù„Ø´Ø§Ø±Øª ÙÙ‚Ø·**\nØ£Ùˆ Ø§Ø¶ØºØ· 'Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©'",
        reply_markup=ReplyKeyboardMarkup([["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]], resize_keyboard=True, one_time_keyboard=False)
    )
    return ANALYZE_MODE

async def handle_photo_in_analyze_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ù„ÙŠÙ„"""
    return await handle_photo_analysis(update, context)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø£Ù…Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©"""
    help_text = """
    ğŸ¤– **Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª:**
    
    /start - Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    /help - Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
    
    âš™ï¸ **ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:**
    1. Ø§Ø³ØªØ®Ø¯Ù… Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù„Ù„ØªÙ†Ù‚Ù„
    2. Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© Ø§Ù„Ø´Ø§Ø±Øª Ù„Ù„ØªØ­Ù„ÙŠÙ„
    3. Ø§Ø®ØªØ± "Ø¯Ø±Ø¯Ø´Ø©" Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª Ø§Ù„Ù†ØµÙŠØ©
    4. Ø§Ø®ØªØ± "ØªÙˆØµÙŠØ©" Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„Ø§Øª
    
    ğŸ“ˆ **Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠØ§Øª:**
    â€¢ ØªØ­Ù„ÙŠÙ„ ÙÙ†ÙŠ Ù„Ù„Ø¹Ù…Ù„Ø§Øª ÙˆØ§Ù„Ù…Ø¤Ø´Ø±Ø§Øª
    â€¢ Ø£Ø±Ø¨Ø¹Ø© Ø£Ù‚Ø³Ø§Ù… Ø±Ø¦ÙŠØ³ÙŠØ©
    â€¢ ØªÙˆØµÙŠØ§Øª Ù…ÙØµÙ„Ø© Ù„ÙƒÙ„ Ø¹Ù…Ù„Ø©
    â€¢ ØªØ­Ù„ÙŠÙ„ Ø³Ø±ÙŠØ¹ ÙˆÙ…Ø¨Ø§Ø´Ø±
    
    â±ï¸ **Ø®Ø§ØµÙŠØ© Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙŠØ¯ÙˆÙŠ:**
    â€¢ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ø¯ÙŠØ¯ ÙˆÙ‚Øª Ø§Ù„ØµÙÙ‚Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹
    â€¢ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©:
      - 00:00:00 (Ø³Ø§Ø¹Ø§Øª:Ø¯Ù‚Ø§Ø¦Ù‚:Ø«ÙˆØ§Ù†ÙŠ)
      - Ø¹Ø¯Ø¯ Ø§Ù„Ø£ÙŠØ§Ù… (Ù…Ø«Ø§Ù„: 2 ÙŠÙˆÙ…)
      - Ø¹Ø¯Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø§Øª (Ù…Ø«Ø§Ù„: 3 Ø³Ø§Ø¹Ø©)
      - Ø¹Ø¯Ø¯ Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚ (Ù…Ø«Ø§Ù„: 45 Ø¯Ù‚ÙŠÙ‚Ø©)
      - Ø¹Ø¯Ø¯ Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ (Ù…Ø«Ø§Ù„: 30 Ø«Ø§Ù†ÙŠØ©)
    
    ğŸ“Š **Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¨ÙˆØª:**
    â€¢ ØªØ­Ù„ÙŠÙ„ ÙÙ†ÙŠ Ù„Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ©
    â€¢ Ø¯Ø±Ø¯Ø´Ø© Ø°ÙƒÙŠØ© Ù…Ø¹ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
    â€¢ Ù†Ø¸Ø§Ù… ØªÙˆØµÙŠØ§Øª Ø§Ù„Ø¹Ù…Ù„Ø§Øª
    â€¢ Ø­ÙØ¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§ØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ©
    â€¢ ÙˆØ§Ø¬Ù‡Ø© Ø³Ù‡Ù„Ø© Ø¨Ø§Ù„Ø£Ø²Ø±Ø§Ø±
    â€¢ Ø¥Ø¯Ø®Ø§Ù„ ÙˆÙ‚Øª Ù…Ø®ØµØµ ÙŠØ¯ÙˆÙŠØ§Ù‹
    """
    await update.message.reply_text(help_text, parse_mode="Markdown")

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©"""
    await update.message.reply_text(
        "ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡. Ø§ÙƒØªØ¨ /start Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯.",
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END

# --- Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ---
async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù…"""
    print(f"âš ï¸ Error occurred: {context.error}")
    
    # ØªØ¬Ø§Ù‡Ù„ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØªØ¹Ø§Ø±Ø¶ Ø§Ù„Ù…Ø¤Ù‚ØªØ©
    if isinstance(context.error, telegram.error.Conflict):
        print("âš ï¸ Conflict error ignored (another instance might be running)")
        return
    
    try:
        if update and update.effective_chat:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹..."
            )
    except:
        pass

# --- Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ ---
def run_flask_server():
    """ØªØ´ØºÙŠÙ„ Flask server"""
    port = int(os.environ.get('PORT', 10000))
    print(f"ğŸŒ Trying to start Flask server on port {port}...")
    
    # Ø­Ø§ÙˆÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù†Ø§ÙØ° Ø¨Ø¯ÙŠÙ„Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† 10000 Ù…Ø´ØºÙˆÙ„Ø§Ù‹
    for p in range(port, port + 5):
        try:
            app.run(host='0.0.0.0', port=p, debug=False, use_reloader=False)
            break
        except OSError as e:
            if "Address already in use" in str(e):
                print(f"âš ï¸ Port {p} is in use, trying next port...")
                continue
            else:
                raise e

def cleanup_bot_sessions():
    """ØªÙ†Ø¸ÙŠÙ Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©"""
    try:
        # Ø¥Ù†Ø´Ø§Ø¡ bot Ù…Ø¤Ù‚Øª Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¬Ù„Ø³Ø§Øª
        temp_bot = telegram.Bot(token=TOKEN)
        
        # Ø­Ø°Ù Webhook Ø¥Ù† ÙˆØ¬Ø¯
        result = temp_bot.delete_webhook(drop_pending_updates=True)
        print("âœ… Deleted any existing webhook")
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„Ù‡
        bot_info = temp_bot.get_me()
        print(f"âœ… Bot verified: {bot_info.first_name} (@{bot_info.username})")
        
        return True
    except telegram.error.Conflict as e:
        print(f"âš ï¸ Conflict during cleanup: {e}")
        print("âš ï¸ Another bot instance might be running. Waiting 5 seconds...")
        time.sleep(5)
        return False
    except Exception as e:
        print(f"âš ï¸ Cleanup warning: {e}")
        return True  # Ù†ÙˆØ§ØµÙ„ Ø­ØªÙ‰ Ù…Ø¹ ÙˆØ¬ÙˆØ¯ Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„ØªÙ†Ø¸ÙŠÙ

def run_telegram_bot():
    """ØªØ´ØºÙŠÙ„ Telegram bot"""
    print("ğŸ¤– Starting Telegram Bot...")
    
    # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
    max_cleanup_attempts = 3
    for attempt in range(max_cleanup_attempts):
        print(f"Attempt {attempt + 1}/{max_cleanup_attempts} to clean bot sessions...")
        if cleanup_bot_sessions():
            print("âœ… Bot sessions cleaned successfully")
            break
        elif attempt == max_cleanup_attempts - 1:
            print("âŒ Failed to clean bot sessions after multiple attempts")
            print("âš ï¸ Trying to continue anyway...")
    
    # ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    init_db()
    
    # Ø¥Ù†Ø´Ø§Ø¡ ØªØ·Ø¨ÙŠÙ‚ Telegram
    application = Application.builder().token(TOKEN).build()
    
    # Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
    application.add_error_handler(error_handler)
    
    # Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            MAIN_MENU: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_main_menu)
            ],
            SETTINGS_CANDLE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_settings_candle)
            ],
            SETTINGS_TIME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_settings_time)
            ],
            SETTINGS_MANUAL_TIME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_manual_time)
            ],
            CHAT_MODE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_chat_message)
            ],
            ANALYZE_MODE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_analyze_mode),
                MessageHandler(filters.PHOTO, handle_photo_in_analyze_mode)
            ],
            RECOMMENDATION_MODE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_recommendation_selection)
            ],
            CATEGORY_SELECTION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_recommendation_selection)
            ],
        },
        fallbacks=[CommandHandler('start', start), CommandHandler('cancel', cancel)],
        allow_reentry=True
    )
    
    application.add_handler(conv_handler)
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("cancel", cancel))
    
    # Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬ Ù„Ù„Ù†ØµÙˆØµ Ø§Ù„Ø¹Ø§Ù…Ø©
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_main_menu))
    
    print("âœ… Telegram Bot initialized successfully")
    print("ğŸ“¡ Bot is now polling for updates...")
    
    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØµØ­ÙŠØ­Ø©
    # Ø¥ØµÙ„Ø§Ø­: Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª ØºÙŠØ± Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø© ÙÙŠ run_polling()
    application.run_polling(
        allowed_updates=Update.ALL_TYPES,
        drop_pending_updates=True,  # Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹ Ù„Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© Ø§Ù„ØªØ¹Ø§Ø±Ø¶
        poll_interval=0.5,
        timeout=30,
        bootstrap_retries=3,
        close_loop=False
    )

def main():
    """Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    print("ğŸš€ Starting Obeida Trading...")
    print(f"ğŸ“… {time.strftime('%Y-%m-%d %H:%M:%S')}")
    
    # ØªØ´ØºÙŠÙ„ Flask ÙÙŠ thread Ù…Ù†ÙØµÙ„
    flask_thread = threading.Thread(target=run_flask_server, daemon=True)
    flask_thread.start()
    
    print(f"ğŸŒ Flask server started in background")
    print("ğŸ”§ Waiting 3 seconds for Flask to initialize...")
    time.sleep(3)
    
    # ØªØ´ØºÙŠÙ„ Telegram bot
    try:
        run_telegram_bot()
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Bot stopped by user")
    except Exception as e:
        print(f"âŒ Critical error: {e}")
        print("ğŸ”„ Restarting in 10 seconds...")
        time.sleep(10)
        main()  # Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„

if __name__ == "__main__":
    main()
